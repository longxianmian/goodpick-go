ä¸€ã€ç›®æ ‡

ç›®å‰çº¿ä¸Šé˜¿é‡Œäº‘æ—¥å¿—ï¼š

[OAUTH INIT] body= { state: undefined, campaignId: '1', returnTo: undefined }
[OAUTH INIT] missing state
400 POST /api/auth/line/init-oauth :: {"success":false,"message":"State ..."}


å¯¼è‡´ H5 è¯¦æƒ…é¡µç‚¹å‡»ã€Œç”¨ LINE ä¸€é”®é¢†å–ã€ç›´æ¥æŠ¥é”™ã€‚

éœ€æ±‚ï¼šåç«¯ç»Ÿä¸€åœ¨æœåŠ¡å™¨ç«¯ç”Ÿæˆ stateï¼Œå³ä½¿å‰ç«¯æ²¡ä¼  stateï¼Œä¹Ÿä¸å†è¿”å› 400ï¼Œè€Œæ˜¯æ­£å¸¸èµ° OAuth æµç¨‹ã€‚

äºŒã€ä»£ç ä¿®æ”¹ï¼ˆåç«¯ routesï¼‰

æ–‡ä»¶ä½ç½®

ä»“åº“ï¼šgoodpick-go

åˆ†æ”¯ï¼šbackup-20251115-prod

æ–‡ä»¶ï¼šserver/routes.ts

ç›®æ ‡ï¼šapp.post('/api/auth/line/init-oauth', ...) è¿™ä¸ªè·¯ç”±

1. å¼•å…¥ nanoidï¼ˆå¦‚æœæœªå¼•å…¥ï¼‰

åœ¨æ–‡ä»¶é¡¶éƒ¨å·²æœ‰ nanoid å°±å¤ç”¨ï¼›å¦‚æœæ²¡æœ‰ï¼Œåˆ™åœ¨å…¶å®ƒ import é™„è¿‘åŠ ä¸€è¡Œï¼š

import { nanoid } from 'nanoid';

2. ä¿®æ”¹ /api/auth/line/init-oauth è·¯ç”±é€»è¾‘

å½“å‰å¤§è‡´ç»“æ„ç±»ä¼¼ï¼š

app.post('/api/auth/line/init-oauth', async (req: Request, res: Response) => {
  try {
    const { state, campaignId, returnTo } = req.body;

    if (!state) {
      console.warn('[OAUTH INIT] missing state', { body: req.body, sessionID: req.sessionID });
      return res.status(400).json({ success: false, message: 'State missing' });
    }

    // è¯»å– / åˆå§‹åŒ– session.oauthStates
    // æ„é€  redirectUri
    // ç”Ÿæˆ LINE OAuth URLï¼ˆå¸¦ stateï¼‰
    // ä¿å­˜ oauthStates[state] = { campaignId, returnTo, timestamp }
    // è¿”å› { success: true }
  } catch (err) {
    ...
  }
});


ğŸ‘‰ æ”¹æˆï¼šåç«¯å…œåº•ç”Ÿæˆ stateï¼Œä¸å†è¿”å› 400ã€‚

è¯·æŠŠè¯¥è·¯ç”±æ”¹æˆç±»ä¼¼ä¸‹é¢çš„é€»è¾‘ï¼ˆä¿æŒåŸæœ‰åŠŸèƒ½ä¸å˜ï¼Œåªè°ƒæ•´ state å¤„ç†ï¼‰ï¼š

app.post('/api/auth/line/init-oauth', async (req: Request, res: Response) => {
  try {
    let { state, campaignId, returnTo } = (req.body ?? {}) as {
      state?: string;
      campaignId?: string;
      returnTo?: string;
    };

    if (!campaignId) {
      return res.status(400).json({ success: false, message: 'campaignId is required' });
    }

    // âœ… åç«¯å…œåº•ç”Ÿæˆ stateï¼Œé¿å… 400
    if (!state) {
      state = nanoid();
      console.warn('[OAUTH INIT] missing state from client, generated on server', {
        state,
        campaignId,
        sessionID: (req as any).sessionID,
      });
    }

    // åˆå§‹åŒ– session.oauthStates
    const sess: any = (req as any).session;
    if (!sess) {
      console.error('[OAUTH INIT] no session object');
      return res.status(500).json({ success: false, message: 'Session not available' });
    }

    if (!sess.oauthStates) {
      sess.oauthStates = {};
    }

    sess.oauthStates[state] = {
      campaignId,
      returnTo: returnTo || undefined,
      timestamp: Date.now(),
    };

    // æ„é€  redirectUriï¼ˆä¿ç•™åŸæœ‰é€»è¾‘ï¼‰
    const protocol = req.get('x-forwarded-proto') || req.protocol;
    const host = req.get('host');
    const redirectUri = `${protocol}://${host}/api/auth/line/callback`;

    // åˆ©ç”¨ç°æœ‰å·¥å…·æ–¹æ³•æ„é€  LINE æˆæƒ URLï¼ˆä¿æŒåŸæ¥çš„å®ç°ï¼‰
    const authUrl = buildLineAuthUrl({
      clientId: LINE_CHANNEL_ID,
      redirectUri,
      state,
    });

    console.log('[OAUTH INIT] stored state OK', {
      state,
      campaignId,
      returnTo,
      sessionID: (req as any).sessionID,
    });

    return res.json({ success: true, redirectUrl: authUrl });
  } catch (error) {
    console.error('[OAUTH INIT] error', error);
    return res.status(500).json({ success: false, message: 'Internal error' });
  }
});


æ³¨æ„ï¼š

ä¿ç•™é¡¹ç›®é‡ŒåŸæ¥æ„é€  LINE OAuth URL çš„æ–¹å¼ï¼ŒåªæŠŠ â€œstate ä¸ºç©ºå°± 400â€ æ”¹ä¸º â€œstate ä¸ºç©ºæ—¶è‡ªåŠ¨ç”Ÿæˆâ€ã€‚

ç¡®ä¿æ—¥å¿—å‰ç¼€ç»§ç»­ä½¿ç”¨ [OAUTH INIT] ...ï¼Œæ–¹ä¾¿æœåŠ¡å™¨æŸ¥çœ‹ã€‚